{"ast":null,"code":"export var pathFromBezierCurve=function pathFromBezierCurve(cubicBezierCurve){var initialAxis=cubicBezierCurve.initialAxis,initialControlPoint=cubicBezierCurve.initialControlPoint,endingControlPoint=cubicBezierCurve.endingControlPoint,endingAxis=cubicBezierCurve.endingAxis;return\"\\n    M\".concat(initialAxis.x,\" \").concat(initialAxis.y,\"\\n    c \").concat(initialControlPoint.x,\" \").concat(initialControlPoint.y,\"\\n    \").concat(endingControlPoint.x,\" \").concat(endingControlPoint.y,\"\\n    \").concat(endingAxis.x,\" \").concat(endingAxis.y,\"\\n  \");};export var radiansToDegrees=function radiansToDegrees(radians){return radians*180/Math.PI;};// https://math.stackexchange.com/questions/714378/find-the-angle-that-creating-with-y-axis-in-degrees\nexport var calculateAngle=function calculateAngle(x1,y1,x2,y2){if(x2>=0&&y2>=0){return 90;}else if(x2<0&&y2>=0){return-90;}var dividend=x2-x1;var divisor=y2-y1;var quotient=dividend/divisor;return radiansToDegrees(Math.atan(quotient))*-1;};export var getCanvasPosition=function getCanvasPosition(event){// mouse position on auto-scaling canvas\n// https://stackoverflow.com/a/10298843/1232793\nvar svg=document.getElementById('aliens-go-home-canvas');var point=svg.createSVGPoint();point.x=event.clientX;point.y=event.clientY;var _point$matrixTransfor=point.matrixTransform(svg.getScreenCTM().inverse()),x=_point$matrixTransfor.x,y=_point$matrixTransfor.y;return{x:x,y:y};};var degreesToRadian=function degreesToRadian(degrees){return degrees*Math.PI/180;};export var calculateNextPosition=function calculateNextPosition(x,y,angle){var divisor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:300;var realAngle=angle*-1+90;var stepsX=radiansToDegrees(Math.cos(degreesToRadian(realAngle)))/divisor;var stepsY=radiansToDegrees(Math.sin(degreesToRadian(realAngle)))/divisor;return{x:x+stepsX,y:y-stepsY};};export var checkCollision=function checkCollision(rectA,rectB){return rectA.x1<rectB.x2&&rectA.x2>rectB.x1&&rectA.y1<rectB.y2&&rectA.y2>rectB.y1;};","map":{"version":3,"names":["pathFromBezierCurve","cubicBezierCurve","initialAxis","initialControlPoint","endingControlPoint","endingAxis","concat","x","y","radiansToDegrees","radians","Math","PI","calculateAngle","x1","y1","x2","y2","dividend","divisor","quotient","atan","getCanvasPosition","event","svg","document","getElementById","point","createSVGPoint","clientX","clientY","_point$matrixTransfor","matrixTransform","getScreenCTM","inverse","degreesToRadian","degrees","calculateNextPosition","angle","arguments","length","undefined","realAngle","stepsX","cos","stepsY","sin","checkCollision","rectA","rectB"],"sources":["C:/Users/dibya/OneDrive/Desktop/VS code/Alien-Go-Home/src/utils/formulas.js"],"sourcesContent":["export const pathFromBezierCurve = (cubicBezierCurve) => {\r\n  const {\r\n    initialAxis, initialControlPoint, endingControlPoint, endingAxis,\r\n  } = cubicBezierCurve;\r\n  return `\r\n    M${initialAxis.x} ${initialAxis.y}\r\n    c ${initialControlPoint.x} ${initialControlPoint.y}\r\n    ${endingControlPoint.x} ${endingControlPoint.y}\r\n    ${endingAxis.x} ${endingAxis.y}\r\n  `;\r\n};\r\n\r\nexport const radiansToDegrees = radians => ((radians * 180) / Math.PI);\r\n\r\n// https://math.stackexchange.com/questions/714378/find-the-angle-that-creating-with-y-axis-in-degrees\r\nexport const calculateAngle = (x1, y1, x2, y2) => {\r\n  if (x2 >= 0 && y2 >= 0) {\r\n    return 90;\r\n  } else if (x2 < 0 && y2 >= 0) {\r\n    return -90;\r\n  }\r\n\r\n  const dividend = x2 - x1;\r\n  const divisor = y2 - y1;\r\n  const quotient = dividend / divisor;\r\n  return radiansToDegrees(Math.atan(quotient)) * -1;\r\n};\r\n\r\nexport const getCanvasPosition = (event) => {\r\n  // mouse position on auto-scaling canvas\r\n  // https://stackoverflow.com/a/10298843/1232793\r\n\r\n  const svg = document.getElementById('aliens-go-home-canvas');\r\n  const point = svg.createSVGPoint();\r\n\r\n  point.x = event.clientX;\r\n  point.y = event.clientY;\r\n  const { x, y } = point.matrixTransform(svg.getScreenCTM().inverse());\r\n  return {x, y};\r\n};\r\n\r\nconst degreesToRadian = degrees => ((degrees * Math.PI) / 180);\r\n\r\nexport const calculateNextPosition = (x, y, angle, divisor = 300) => {\r\n  const realAngle = (angle * -1) + 90;\r\n  const stepsX = radiansToDegrees(Math.cos(degreesToRadian(realAngle))) / divisor;\r\n  const stepsY = radiansToDegrees(Math.sin(degreesToRadian(realAngle))) / divisor;\r\n  return {\r\n    x: x +stepsX,\r\n    y: y - stepsY,\r\n  }\r\n};\r\n\r\nexport const checkCollision = (rectA, rectB) => (\r\n  rectA.x1 < rectB.x2 && rectA.x2 > rectB.x1 &&\r\n  rectA.y1 < rectB.y2 && rectA.y2 > rectB.y1\r\n);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}